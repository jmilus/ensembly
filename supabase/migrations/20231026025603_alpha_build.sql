drop policy "tenant policy" on "public"."Address";

alter table "public"."Event" drop constraint "Event_location_fkey";

alter table "public"."EventModel" drop constraint "EventModel_location_fkey";

alter table "public"."EventModel" from constraint "EventModel_type_fkey";

alter table "public"."Profile" drop constraint "Profile_role_fkey";

alter table "public"."Address" drop constraint "Address_type_fkey";

alter table "public"."Division" drop constraint "Division_capacity_fkey";

alter table "public"."LineupAssignment" drop constraint "LineupAssignment_lineup_fkey";

alter table "public"."Member" drop constraint "Member_sex_fkey";

alter table "public"."PhoneNumber" drop constraint "PhoneNumber_type_fkey";

alter table "public"."SecurityRole" drop constraint "Security_name_key";

alter table "public"."Profile" drop constraint "Profile_pkey";

drop index if exists "public"."Profile_pkey";

drop index if exists "public"."Security_name_key";

create table "public"."MembershipType" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "name" text default ''::text,
    "tenant" uuid not null default get_user_tenant(),
    "capacity" text[],
    "term_length" smallint,
    "term_period" bigint,
    "ensembles" uuid[]
);

--

alter table "public"."EventModel" rename column "type" to "type_old";

alter table "public"."EventModel" add column "type" text;

update "EventModel" set "type" = (select "type" from "EventType" where "EventType".id = "EventModel".type_old);

alter table "public"."EventModel" drop column "type_old";

--

alter table "public"."MembershipType" enable row level security;

alter table "public"."Address" add column "tenant" uuid default get_user_tenant();

alter table "public"."Address" alter column "type" set data type text using "type"::text;

alter table "public"."Broadcast" alter column "status" drop not null;

alter table "public"."Broadcast" alter column "subject" drop not null;

-- alter table "public"."Division" alter column "capacity" set data type bigint using "capacity"::bigint;

alter table "public"."EnsembleMembership" drop column "statusDate";

alter table "public"."EnsembleMembership" drop column "statusNote";

alter table "public"."EnsembleMembership" add column "membership_expires" date;

alter table "public"."EnsembleMembership" add column "membership_start" date;

alter table "public"."EnsembleMembership" add column "membership_type" bigint;

alter table "public"."EnsembleMembership" add column "status_date" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text);

alter table "public"."EnsembleMembership" add column "status_note" text;

alter table "public"."Event" drop column "location";

alter table "public"."Event" add column "address" uuid;

alter table "public"."EventModel" rename column "location" to "address";

alter table "public"."Lineup" drop column "lineup_divisions";

alter table "public"."Member" alter column "firstName" set not null;

alter table "public"."Member" alter column "lastName" set not null;

alter table "public"."Member" alter column "middleName" set not null;

alter table "public"."Member" alter column "suffix" set not null;

alter table "public"."MembershipStatus" add column "color" text default ''::text;

alter table "public"."PhoneNumber" alter column "type" set data type text using "type"::text;

alter table "public"."Profile" drop column "role";

alter table "public"."Profile" add column "id" uuid not null default gen_random_uuid();

alter table "public"."Profile" add column "roles" text[];

alter table "public"."Profile" alter column "tenant" drop not null;

alter table "public"."SecurityRole" rename column "role" to "role_name";

CREATE UNIQUE INDEX "MembershipType_name_key" ON public."MembershipType" USING btree (name);

CREATE UNIQUE INDEX "MembershipType_pkey" ON public."MembershipType" USING btree (id);

CREATE UNIQUE INDEX "Profile_pkey" ON public."Profile" USING btree (id);

CREATE UNIQUE INDEX "Security_name_key" ON public."SecurityRole" USING btree (role_name);

alter table "public"."MembershipType" add constraint "MembershipType_pkey" PRIMARY KEY using index "MembershipType_pkey";

alter table "public"."Profile" add constraint "Profile_pkey" PRIMARY KEY using index "Profile_pkey";

alter table "public"."Address" add constraint "Address_tenant_fkey" FOREIGN KEY (tenant) REFERENCES "Tenant"(id) ON DELETE CASCADE not valid;

alter table "public"."Address" validate constraint "Address_tenant_fkey";

alter table "public"."EnsembleMembership" add constraint "EnsembleMembership_membership_type_fkey" FOREIGN KEY (membership_type) REFERENCES "MembershipType"(id) not valid;

alter table "public"."EnsembleMembership" validate constraint "EnsembleMembership_membership_type_fkey";

alter table "public"."Event" add constraint "Event_address_fkey" FOREIGN KEY (address) REFERENCES "Address"(id) ON DELETE SET NULL not valid;

alter table "public"."Event" validate constraint "Event_address_fkey";

alter table "public"."EventModel" add constraint "EventModel_address_fkey" FOREIGN KEY (address) REFERENCES "Address"(id) ON DELETE SET NULL not valid;

alter table "public"."EventModel" validate constraint "EventModel_address_fkey";

alter table "public"."EventModel" add constraint "EventModel_type_fkey" FOREIGN KEY (type) REFERENCES "EventType"(type) ON DELETE SET NULL not valid;

alter table "public"."EventModel" validate constraint "EventModel_type_fkey";

alter table "public"."MembershipType" add constraint "MembershipType_name_key" UNIQUE using index "MembershipType_name_key";

alter table "public"."MembershipType" add constraint "MembershipType_tenant_fkey" FOREIGN KEY (tenant) REFERENCES "Tenant"(id) ON DELETE CASCADE not valid;

alter table "public"."MembershipType" validate constraint "MembershipType_tenant_fkey";

alter table "public"."MembershipType" add constraint "MembershipType_term_period_fkey" FOREIGN KEY (term_period) REFERENCES "RecurrencePeriod"(id) not valid;

alter table "public"."MembershipType" validate constraint "MembershipType_term_period_fkey";

alter table "public"."Address" add constraint "Address_type_fkey" FOREIGN KEY (type) REFERENCES "AddressType"(type) ON DELETE SET NULL not valid;

alter table "public"."Address" validate constraint "Address_type_fkey";

alter table "public"."Division" add constraint "Division_capacity_fkey" FOREIGN KEY (capacity) REFERENCES "MembershipCapacity"(type) not valid;

alter table "public"."Division" validate constraint "Division_capacity_fkey";

alter table "public"."LineupAssignment" add constraint "LineupAssignment_lineup_fkey" FOREIGN KEY (lineup) REFERENCES "Lineup"(id) ON DELETE CASCADE not valid;

alter table "public"."LineupAssignment" validate constraint "LineupAssignment_lineup_fkey";

alter table "public"."Member" add constraint "Member_sex_fkey" FOREIGN KEY (sex) REFERENCES "Sex"(id) not valid;

alter table "public"."Member" validate constraint "Member_sex_fkey";

alter table "public"."PhoneNumber" add constraint "PhoneNumber_type_fkey" FOREIGN KEY (type) REFERENCES "PhoneType"(type) ON DELETE SET NULL not valid;

alter table "public"."PhoneNumber" validate constraint "PhoneNumber_type_fkey";

alter table "public"."SecurityRole" add constraint "Security_name_key" UNIQUE using index "Security_name_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.calc_membership_expiration()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$begin
  IF new.membership_expires IS NULL
  THEN
    new.membership_expires:= (select (m.membership_start + concat (t.term_length, ' ', r.type, 's')::interval)::date
    from "EnsembleMembership" m JOIN "MembershipType" t ON m.membership_type = t.id JOIN "RecurrencePeriod" r ON r.id = t.term_period
    where m."id" = new.id)
    where mm."id" = new.id;
  END if;
  return new;
end$function$
;

CREATE OR REPLACE FUNCTION public.clone_broadcast(broadcast_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$declare
  clone_id uuid;
begin
  insert into "Broadcast" ("subject", "body", "status", "tenant", "to_address", "cc_address", "bcc_address")
  select "subject", "body", 'DRAFT', "tenant", "to_address", "cc_address", "bcc_address"
  from "Broadcast"
  where id = broadcast_id
  returning "id" into clone_id;
  return clone_id;
end$function$
;

CREATE OR REPLACE FUNCTION public.conform_subdivision_capacities()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$begin
  update "Division"
  set "capacity" = new.capacity
  where "parent_division" = new.id;
  return new;
end$function$
;

CREATE OR REPLACE FUNCTION public.delete_child_divisions()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$begin
  delete
  from "Division"
  where "parent_division" = old.id;
  return null;
end$function$
;

CREATE OR REPLACE FUNCTION public.orphan_address_handler()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
  IF new."address" IS NULL and old."address" is not null
  THEN
    if not exists (
      select 1 
      from "Address" 
      where "Address".id = old."address" and "Address".member is not null 
    ) and NOT EXISTS (
      SELECT 1
      FROM "Event"
      WHERE "Event".address = old."address" and "Event".id != old.id
    ) AND NOT EXISTS (
      SELECT 1
      FROM "EventModel"
      WHERE "EventModel".address = old."address" and "EventModel".id != old.id
    )
    THEN
      DELETE FROM "Address"
      WHERE "Address"."id" = old."address";
    END IF;
  END IF;
  RETURN new;
END;$function$
;

CREATE OR REPLACE FUNCTION public.clone_lineup(lineup_id uuid, new_name text)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
declare clone_id uuid;
begin
  insert into "Lineup" (name, ensemble, is_primary)
  select new_name, ensemble, false from "Lineup" where "id" = lineup_id
  returning id into clone_id;
  INSERT INTO "LineupAssignment" ("lineup", "membership", "division", "title")
  SELECT clone_id, "membership", "division", "title"
  FROM "LineupAssignment"
  WHERE lineup = lineup_id;
  return clone_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_model_recurrence_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  event_date date;
  start_date timestamptz;
  end_date timestamptz;
  model_id uuid := old."id";
  model_start_date timestamptz := COALESCE (new."modelStartDate", old."modelStartDate");
  model_end_date timestamptz := COALESCE (new."modelEndDate", old."modelEndDate");
  recurrence_end_date date := COALESCE (new."recurrenceEndDate", old."recurrenceEndDate");
  model_interval smallint := COALESCE (new."interval", old."interval");
  model_period bigint := COALESCE (new."period", old."period");
  model_occurrence text[] := COALESCE (new."occurrence", old."occurrence");
  model_tenant uuid := old."tenant";
  it_exists boolean;
  date_list date[];
begin
  IF recurrence_end_date IS NOT NULL THEN
    date_list := get_dates_by_occurrence(model_start_date, recurrence_end_date, model_interval, model_period, model_occurrence);
  
    FOREACH event_date IN ARRAY date_list
    LOOP
      start_date = event_date + CONCAT(date_part('hour', model_start_date), ' hours ', date_part('minute', model_start_date), ' minutes ', date_part('second', model_start_date), ' seconds')::interval;

      IF EXISTS (select * from "Event" where "anchorDate" = event_date and "model" = model_id)
      THEN
       UPDATE "Event" SET "eventStartDate" = start_Date where "anchorDate" = event_date and "model" = model_id; 
      ELSE
        end_date = start_date + (model_end_date - model_start_date);

        INSERT INTO "Event" ("anchorDate", "eventStartDate", "eventEndDate", "model", "tenant")
        VALUES (event_date, start_date, end_date, model_id, model_tenant);
      END IF;
    END LOOP;

    DELETE from "Event"
    WHERE "exception" = false 
    AND NOT "anchorDate" = ANY(date_list)
    AND "eventStartDate" > now();
  END IF;

  return null;
end;
$function$
;

create policy "tenant policy"
on "public"."MembershipType"
as permissive
for all
to authenticated
using ((get_user_tenant() = tenant))
with check ((get_user_tenant() = tenant));


create policy "tenant policy"
on "public"."Address"
as permissive
for all
to authenticated
using ((get_user_tenant() = tenant))
with check ((get_user_tenant() = tenant));


CREATE TRIGGER conform_division_capacity_trigger AFTER UPDATE ON public."Division" FOR EACH ROW EXECUTE FUNCTION conform_subdivision_capacities();

CREATE TRIGGER delete_child_divisions_trigger AFTER DELETE ON public."Division" FOR EACH ROW EXECUTE FUNCTION delete_child_divisions();

CREATE TRIGGER calc_membership_expiration_trigger BEFORE INSERT ON public."EnsembleMembership" FOR EACH ROW EXECUTE FUNCTION calc_membership_expiration();

CREATE TRIGGER orphan_address_handler_trigger AFTER DELETE OR UPDATE ON public."Event" FOR EACH ROW EXECUTE FUNCTION orphan_address_handler();
